---
alwaysApply: true
description: |
  Enforce modular RAD framework structure, coding standards, middleware usage,
  TypeScript typing, Zustand central store management, API and routing conventions,
  security and extensibility rules strictly within src/modules, src/core, and src/app.
globs:
  - "src/modules/**/*.ts"
  - "src/modules/**/*.tsx"
  - "src/core/**/*.ts"
  - "src/core/**/*.tsx"
  - "src/app/**/*.ts"
  - "src/app/**/*.tsx"
---

# Modular Folder Structure
- Enforce feature code under /src/modules/[moduleName]/ with api/, components/, routes/, services/, store/, schemas/, types/ folders.
- Use shared code from /src/core/ only. No duplication.
  
# State Management
- Use centralized Zustand stores via core store factory.
- Follow persist/devtools config per module.
- Ensure registration in global store registry.

# Middleware & Validation
- Every API handler must call middleware in order (auth → permissions → validation).
- Middleware as defined in module config files must be respected.
- Input/output must be validated with Zod schemas. Type safety mandatory.

# API & Routing
- API handlers located in api/handlers/.
- Registered dynamically via core API router.
- Page components use Next.js app router with file-based routing, as per module.config.json.

# Coding Standards
- Use camelCase variables, PascalCase components and types.
- Add meaningful comments.
- Avoid dependencies outside prescribed tech stack.

# Extensibility
- Core extensions only under /src/core/extensions/.
- Modules consume these via middleware or services.

# Error Handling & Logging
- Consistent HTTP codes and structured error messages.
- Use centralized core logging system.

# Security
- Sanitize inputs.
- Protect routes with authentication and permission middleware.
- Do not leak sensitive info.

# Behavior
- Always inspect existing files before modifying/creating.
- Explain major architectural decisions clearly.
- Validate code strictly against these rules.
- Provide corrective suggestions for violations.
